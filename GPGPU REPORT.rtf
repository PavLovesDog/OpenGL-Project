{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 ----------\line  GPGPU\line ----------\par
-- What Is It? --\par
General Purpose Graphics Processing Unit(GPU), is a processing unit which performs general calculations with great parallelism, due to its many cores, which would otherwise run through the CPU.\line Usually, the Graphics Processing Unit(GPU) is dedicated to graphics rendering.\line However, the term GPGPU came about when code began to be optimized to run through the GPU rather than CPU. As the technology and need for software parallelism grew, the CPU quickly became unable to keep up due to its sequential nature, where the GPU could handle massive amounts of data as long as the code was written for its architecture.\line *prevalently this is within the areas of machine learning (A.I), crypto-mining, graphics-rendering (the GPUs original function), scientific computations & other physics calculations. \par
-- Why Do We Use It? --\par
Unlike the CPU, the GPU was designed to calculate vast sums of equations or tasks in parallel, so for displaying graphics to a screen the GPU can handle the operation quickly and efficiently without taxing all resources, where the CPU would be left behind trying to solve all graphics equations sequentially. \line We use this technology to handle massive amounts of data which require specific tasks, or similar calculations performed on every set of data (such as linear algebra, floating-point clculations etc.), that need to be solved simultaneuosly for correct & smooth data output of the program running the code.\par
-- Why Do We Need It? --\par
Thousands to millions of calculations are performed every second over the many cores of the GPU, this enables the display on your device to be constantly updated and provide a clean, smooth viewing experience. without a GPU, modern day graphics would greatly hinder the CPU & we'd probably all be outside looking at nature instead.\line We need General Purpose Graphics Processing Unit programming for the ever growing demand for better graphics and the exploration into better, 'smarter' technology for the uses stated above (look for the *).\line\par
------------------------------------------------\line  CPU vs. GPU - What's The Difference?\line ------------------------------------------------\par
CPUs and GPUs are designed for specific purposes.\line The CPU architecture is designed to handle a wide range of tasks sequentially. That is, it has a few large cores and large memory size for task-parallelism with high clock speeds. This gives the illusion of parallelism, but is essentially only running one task at a time.\line The GPU architecture is throughput-optimized for high-end parallel computing, be it for graphical computing, machine-learning or scientific computation. it is comprised of thousands of tiny cores for high memory throughput and data parallelism.\line The GPU is optimized for dimensional matrix arithmetic and floating point calculations.\par
-- The architecture of Nividia GPUs are as follows: --\line All cores are distributed over a few Graphics Processing Clusters (GPC).\line Each GPC contains Streaming Multiprocessors (SM), how many depends on GPU model.\line Each CUDA core, or, Streaming Processor (SP) is distributed over the SMs.\line These SMs only get one instruction at time which means that the corresponding SPs all execute the same instruction. This is done through a warp (32 threads for current hardware).\line So if you had a warp of 32 threads (32 CUDA cores), in 16 SMs, within 4 GPCs, you'd have a 2,048 core GPU (thats 32 x 16 x 4 = 2,048).\line\line Most GPU's follow a similar architecture with varying amounts of cores.\line\par
----------------------\line  GPU Pros & Cons\line ----------------------\par
- arithmetic complexity: designed for small set calculations such as linear algebra.\par
- high parallelism: designed to rapidly manipulate huge chunks of data all at once.\par
- GPU memory limits: memory access has high latency\line\par
----------------------\line  Graphics Pipeline\line ----------------------\par
The Graphics Pipeline(GP) consists of a few stages. these stages generally go as follows:\par
Vertex Specification -> Vertex Shader -> Vertex Post Processing -> Primitive Assembly -> Rasterization -> Fragment Shader -> Per Sample Operation -> Frame Buffer \par
But, as programmers we focus on two stages called Vertex Processing(VP) & Fragment Processing(FP). These are the 2 stages of the GP which are programmable and where we have control of what is rendered. Along with these stages there are also the Rasterization(R) stage and the Frame Buffer(FB). These are important as they slot in between our programmable stages.\par
Our programmable order: VP --> R --> FP --> FB\par
Once data is fed into the pipeline, The Vertex Processing begins with positional coordinates. first the Vertex Shader uses the data provided and creates vertices within 3D space, then the Primitive Assembly joins those vertices in a pre-calculation to determine triangles, quads, lines or points. Once the primitives are assembled, the Rasterization then converts the calculations of vertices within 3D space into a 2D set of pixels, or a raster. This process is called multisampling and smoothing. \line Next the Fragment Processing begins. The purpose of the FP is to provide colour data for pixels with the Fragment Shader via textures, alpha or depth data.\line Depending on the data fed into the Fragment Shader, the pixel becomes coloured and then is passed into the Frame Buffer where colours are blended and displayed.\line The Frame Buffer is always the output of a Graphics pipeline, unless a Compute Shader is operating within the program.\line\par
---------------------\line Compute Shader\line ---------------------\par
The Compute Shader is a tool for GPGPU programming designed to distribute work over a specified number of threads to run on the GPU. This essentially opens up the power of the GPU for non-rendering purposes or tasks in a controllable way.\line Compute Shader can save the data its generated in the pipeline and return it back through the graphic pipeline or read back to the CPU for further manipulation. This is particularly handy for handling tasks like particle movement, where positions of vertices are constantly updated.\line Though Compute Shader can handle rendering triangles and pixels, its generally reserved for tasks outside of the rendering stage.\line\par
-----------\line  OpenGL\line -----------\par
At its core, OpenGL(Open Graphics Library) is an application programming interface(API) for rendering 2D and 3D vector graphics.\line It is a software interface into graphical hardware and is almost exclusively used with the GPU.\par
-- why do we need openGL & compute shades? --\par
We need OpenGL, like any graphical API, for any graphics rendering we wish to do and would be hard pressed to do it without them. As OpenGL follows a strict graphic pipeline and always outputs to the FrameBuffer, a Compute Shader is required to further manipulate data flowing through the pipeline, if data is needed to be changed or updated.\line\line ----------------\line  My Program\line ----------------\par
-- Explaining the Mandlebrot Set --\par
My program is using the OpenGl API to generate a Mandlebrot set, this is calculated by computing pixel position to a complex number(c) with two parts;\line c.real & c.imaginary\line By setting these values to variables determined by window width & height (also with 'Pan' and 'Zoom' variables for their respective functions), we then iterate through the equation: \line Zn = Z(n-1)^2 + c (where n is the number of iterations), to determine convergent and divergent points for each pixel.\line Convergent pixels are painted black & divergent are painted a color determined by their position within the Mandlebrot Set.\par
-- how is my .vert & .frag run in parallel for each pixel? --\par
the files 'default.vert' & 'default.frag' are loaded into my shader class and activated, so OpenGL knows where to read from when it gets to work on its pixels. Due to the nature of the OpenGL API the code on the shader files are run in parallel through the GPU to produce their results!\par
}
 